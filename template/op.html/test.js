// Copyright (c) Microsoft. All rights reserved. Licensed under the MIT license. See LICENSE file in the project root for full license information.
var fs = require('fs');
var Mustache = require('mustache');
var jsyaml = require('js-yaml');
var path = require('path');
var mkdirp = require('mkdirp');
var extension = ".html";
var options = { encoding: 'utf8' };
var templateName = path.basename(process.cwd());
var content = fs.readFileSync(templateName + '.js', options);
var template = fs.readFileSync(templateName + '.tmpl', options);
eval(content);
var dir = "sample";
var output = "dist";
var root = "./";
var tocFile = 'toc.yml';
walk(dir, function (err, files) {
  if (err) return console.log(err);
  parse(dir, output, root, files, function (file, index) {
    if (path.extname(file) === '.yml') return true;
    return false;
  }, transform);
});

function walk(dir, done) {
  var results = [];
  fs.readdir(dir, function (err, list) {
    if (err) return done(err);
    var pending = list.length;
    if (!pending) return done(null, results);
    list.forEach(function (file) {
      file = path.resolve(dir, file);
      fs.stat(file, function (err, stat) {
        if (stat && stat.isDirectory()) {
          walk(file, function (err, res) {
            results = results.concat(res);
            if (!--pending) done(null, results);
          });
        } else {
          results.push(file);
          if (!--pending) done(null, results);
        }
      });
    });
  });
}

function parse(input, output, root, files, filter, callback) {
  if (!callback) return console.error("Callback is not defined.");
  var extChanger = changeExt(extension);
  var srcFileExtChanger = changeExt(".json");
  input = path.resolve(input);
  var nav = extChanger(path.join(input, tocFile));
  output = path.resolve(output);
  root = path.resolve(root);
  files.forEach(function (file, idx) {
    if (!filter(file, idx)) return;
    var toc = extChanger(getClosestFile(input, file, tocFile));
    var currentFolder = path.dirname(file);
    var navRelPath = path.relative(currentFolder, nav)
    var tocRelPath = path.relative(currentFolder, toc);
    var navRel = path.dirname(navRelPath);
    var tocRel = path.dirname(tocRelPath);
    var outputPath = path.join(output, path.relative(input, file));
    var outputFilePath = extChanger(outputPath);
    var outputModelFilePath = srcFileExtChanger(outputPath);
    var rel = path.relative(path.dirname(outputPath), root);
    var attrs = {
      _lang: "csharp",
      _title: "Writing Documentations as writing code | Generated by docfx",
      _tocTitle: "Api Reference",
      _name: "Docfx",
      _tocPath: tocRelPath,
      _navPath: navRelPath,
      _ext: extension,
      _rel: rel ? rel + '\\' : '',
      _navRel: navRel,
      _tocRel: tocRel,
      _description: "This description will be used in search results.",
    };
    fs.readFile(file, options, function (err, data) {
      if (err) return console.log(err);
      var input = jsyaml.load(data);
      var model = callback(input, attrs);
      if (!model) return;
      var output = Mustache.render(template, model);
      if (/^\s*$/.test(output)) {
        console.warn("WARNING: Template generated nothing for " + file);
      } else {
        var folder = path.dirname(outputFilePath);
        mkdirp.sync(folder);
        fs.writeFile(outputModelFilePath, JSON.stringify(model), options, function (err) {
          if (err) return console.log(err);
        })
        fs.writeFile(outputFilePath, output, options, function (err) {
          if (err) return console.log(err);
          console.log("Template generated to " + outputFilePath);
        })
      }
    })
  });

  function getClosestFile(root, currentFile, targetFileName) {
    var relative = path.relative(root, currentFile);
    var folders = relative.split(path.sep);
    var l = folders.length;
    if (l === 0 || folders[0] === '..') return null;
    while (l > 0) {
      l--;
      relative = path.join(relative, '..');
      var file = path.join(root, relative, targetFileName);
      try {
        var stats = fs.lstatSync(file);
        if (stats.isFile()) return file;
      } catch (e) { }
    }
    return null;
  }
  
  function changeExt(e) {
    var ext = e;
    return function (path) {
      // if ext is empty, remove current extension
      if (!path || ext === undefined) return path;
      var pathWithoutExt = path.substring(0, path.lastIndexOf('.'));
      if (ext && ext[0] !== '.') return pathWithoutExt + '.' + ext;
  
      return pathWithoutExt + ext;
    }
  }
}


